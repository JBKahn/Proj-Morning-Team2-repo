![alt tag](https://raw.githubusercontent.com/csc301-fall2014/Proj-Morning-Team2-repo/master/Phase4/architecture.png?token=ACiBvY26Soz9_blBv0WL_A_Xe-adt-vlks5UhV7DwA%3D%3D)

The architecture of the brunt of the application is split into several sections: the frontend Angular application, the server-side Django view, the API, the Google API interface and the Google API. These are connected as shown in the diagram, in the above order and can only communicate with adjacent members. The main reason for this is security and separation of concerns. The frontend application does not need to know about the fact the event source and destination of updates is Google Calendar and can treat the events as generic. The frontend also must call the backend to request information from Google, this means we do not expose the access or refresh token to the browser which prevents a man-in-the-middle attack for that information. Additionally, all users can only request information regarding the account they have logged into and not any user in our system. Once the frontend [requests information or posts an update](https://github.com/csc301-fall2014/Proj-Morning-Team2-repo/blob/master/AbArticulus/time_table/static_src/js/services/timeTableCalendarService.js), this is the [Django view](https://github.com/csc301-fall2014/Proj-Morning-Team2-repo/blob/master/AbArticulus/time_table/views.py#L100). Django will then reapply any frontend form validation, if there were applicable fields, and then proceed to ship the information in a consumable format to our [API](https://github.com/csc301-fall2014/Proj-Morning-Team2-repo/blob/master/AbArticulus/api/interfaces/api_interface.py#L100). When our API receives this information, it will subsequently ensure that all the database information is kept in sync and that the request information is valid as far as the database is concerned. If it passes that validation, it is packaged up in a way that the Google API will understand and it sent to the [Google API interface](https://github.com/csc301-fall2014/Proj-Morning-Team2-repo/blob/master/AbArticulus/api/interfaces/google_api_interface.py#L41). This last interface ships the request off to the Google API and handles making and routing the request. In this scheme, the [frontend uses the publisher subscriber pattern to detect the users input](https://github.com/csc301-fall2014/Proj-Morning-Team2-repo/blob/master/AbArticulus/time_table/static_src/js/controllers/ngCalendarCtrl.js#L115) and send the correct request and then both the Django view and the Google API interface act as adapters. The response then bubbles back down the chain, with our API making necessary database changes and the frontend application [responding to the response](https://github.com/csc301-fall2014/Proj-Morning-Team2-repo/blob/master/AbArticulus/time_table/static_src/js/controllers/ngCalendarCtrl.js#L119).

A major architectural decision that we made was to [jsonify all the event metadata](https://github.com/csc301-fall2014/Proj-Morning-Team2-repo/blob/master/AbArticulus/api/interfaces/api_interface.py#L322) (votes for times, alternate times, comments, tags) on the Google event itself. On each request, the metadata sent is generated based on the state in the database. This allows us a relatively simple and mostly dependable form of concurrency. Even if a request with prior metadata overwrites a later request (that arrived first), the next write will have the correct data since it uses the database. By doing this, we save considerable time generating the content for the user and can simply pipe a slightly modified version of the response from Google instead of reading from our database. We do however store this information in [Calendar, GoogleEvent, Event, Tag, Comment and Vote models](https://github.com/csc301-fall2014/Proj-Morning-Team2-repo/blob/master/AbArticulus/abcalendar/models.py). This has worked out exactly as expected!

By making all the course-code/section-code calendars shared on a user we control, other users can view this information on the event but cannot edit it as they don't have sufficient privileges ([reader only](https://github.com/csc301-fall2014/Proj-Morning-Team2-repo/blob/master/AbArticulus/api/interfaces/api_interface.py#L107)). This allows meant we didn't have to reinvent the wheel for shared calendars.
